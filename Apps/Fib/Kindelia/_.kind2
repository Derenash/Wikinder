// #kdl_state = Apps.Fib.Kindelia.State.Build
// #kdl_name = Fib
// Apps.Fib.Kindelia (action: Apps.Fib.Kindelia.Act) : Kindelia.IO Apps.Fib.Kindelia.Response 
// Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.next code) = 
//   (Kindelia.IO.do_take (state: Apps.Fib.Kindelia.State) =>
//     // let blk    = (U120.new 0 0)
//     let result = Apps.Fib.Kindelia.State.update state code blk
//     let state  = Pair.fst result
//     (Kindelia.IO.do_save state (_: Unit) =>
//       Kindelia.IO.done (Apps.Fib.Kindelia.Response.next result )
//     )
//   )
// Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.get) = 
//   (Kindelia.IO.do_take (state: Apps.Fib.Kindelia.State) =>
//     (Kindelia.IO.do_save state (_: Unit) =>
//       Kindelia.IO.done (Apps.Fib.Kindelia.Response.state state)
//     )
//   )
// Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.join subj kgt) = 
//   (Kindelia.IO.do_take (state: Apps.Fib.Kindelia.State) =>
    
//     (Kindelia.IO.do_save state (_: Unit) =>
//       Kindelia.IO.done (Apps.Fib.Kindelia.Response.next result )
//     )
//   )
  
Fib.init {
  Apps.Fib.Kindelia.State.Build
}

#kdl_state = Apps.Fib.Kindelia.State.Build
#kdl_name = Fib
Apps.Fib.Kindelia (action: Apps.Fib.Kindelia.Act) : Kindelia.IO Apps.Fib.Kindelia.Response 
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.action code) = 
  do Kindelia.IO {
    ask state  = Kindelia.IO.take
    ask block  = Kindelia.IO.tick
    let pair   = Apps.Fib.Kindelia.State.update state code block
    let events = Pair.snd pair
    let state  = Pair.fst pair
    let result = if (List.is_nil events) {Apps.Fib.Kindelia.Response.act_fail} else {Apps.Fib.Kindelia.Response.acted events}
    ask          Kindelia.IO.save state
    return result
  }
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.get) =
  do Kindelia.IO {
    ask state  = Kindelia.IO.load
    let result = Apps.Fib.Kindelia.Response.state state
    return result
  }
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.join subj kgt) =
  do Kindelia.IO {
    ask state  = Kindelia.IO.take
    let phase  = Apps.Fib.Kindelia.State.get_phase state
    match Apps.Fib.Kindelia.State.Phase phase {
      game  => do Kindelia.IO {
        let result = Apps.Fib.Kindelia.Response.wrong_phase
        ask          Kindelia.IO.save state
        return result 
      }
      lobby => do Kindelia.IO {
        let queue   = phase.queue
        let user    = Apps.Fib.Kindelia.State.Phase.User.new subj kgt
        let size    = U120.to_nat (U120.new 0 10)
        let pair    = Data.LimitedQueue.Sorted.add size (queue) user
        let last    = Apps.Fib.Kindelia.State.Phase.User.kgt (Pair.fst pair)
        let queue   = Pair.snd pair
        let cond    = x => U120.equal subj (Apps.Fib.Kindelia.State.Phase.User.kgt x)
        let find    = Data.LimitedQueue.Sorted.find size cond queue
        let phase   = Apps.Fib.Kindelia.State.Phase.lobby queue
        let state   = Apps.Fib.Kindelia.State.set_phase state phase
        ask           Kindelia.IO.save state
        match Maybe find {
          some =>
            let position = find.value
            let result   = Apps.Fib.Kindelia.Response.joined position
            Kindelia.IO.done result          
          none => 
            let floor = Data.LimitedQueue.get_last size (Data.LimitedQueue.Sorted.queue size queue)
            let result =  Apps.Fib.Kindelia.Response.join_fail (Maybe.extract floor (U120.new 0 0) (x => Apps.Fib.Kindelia.State.Phase.User.kgt x))
            Kindelia.IO.done result
        }
      }   
    }
  }
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.start) =
  do Kindelia.IO {
    ask state = Kindelia.IO.take
    ask tick  = Kindelia.IO.tick
    match Apps.Fib.Kindelia.State state {
      new => 
        let phase = state.phase
        match Apps.Fib.Kindelia.State.Phase phase {
          game  => do Kindelia.IO {
            ask          Kindelia.IO.save state
            let result = Apps.Fib.Kindelia.Response.wrong_phase
            return result
          }
          lobby => 
            let to_start  = U120.new 0 300
            let duration  = U120.sub_saturated tick state.start
            let can_start = U120.greater_equal duration to_start
            if can_start {
              // TODO: Change to actually places players in the PatriciaTree
              let size   = U120.to_nat (U120.new 0 10)
              let starts = Apps.Fib.Map.initial_positions
              let acc    = Apps.Fib.Kindelia.To_start.new starts User.Sipher.PatriciaTree.empty (Apps.Fib.Kindelia.State.get_state state) (U120.new 0 0)
              let data   = Data.LimitedQueue.Sorted.foldl size acc (x => Apps.Fib.Kindelia.To_start.to_fold) phase.queue
              match Apps.Fib.Kindelia.To_start data {
                new => do Kindelia.IO {
                  let phase  = Apps.Fib.Kindelia.State.Phase.game data.users
                  let timer  = U120.new 0 0
                  let state  = data.state 
                  let state  = Apps.Fib.Kindelia.State.new phase timer state
                  let result = Apps.Fib.Kindelia.Response.started tick
                  ask          Kindelia.IO.save state
                  return result
                }
              }
            }
            else {
              do Kindelia.IO {
                let result = Apps.Fib.Kindelia.Response.start_fail (U120.sub_saturated to_start duration)
                ask          Kindelia.IO.save state
                return result
              }   
            }
      }
    }
  }



// Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.get)
// Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.get) = 
//   (Kindelia.IO.do_take (state: Apps.Fib.Kindelia.State) =>
//     (Kindelia.IO.do_save state (_: Unit) =>
//       Kindelia.IO.done (Apps.Fib.Kindelia.Response.state state)
//     )
//   )
// Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.join subj kgt) = 
//   (Kindelia.IO.do_take (state: Apps.Fib.Kindelia.State) =>
    
//     (Kindelia.IO.do_save state (_: Unit) =>
//       Kindelia.IO.done (Apps.Fib.Kindelia.Response.next result )
//     )
//   )
  