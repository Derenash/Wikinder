//The puzzle state consists of seven bits, 3 pairs of bits for each obelisk and one to signal wether the puzzle is in the solved state or not
//The data argument is simply a way to signal which obelisk (or pair of obelisks if you may) the player is interacting with
//0 for first and last, 1 for second and first, 2 for last and second, those are defined on the pair function.
#kdl_name = Fib_npc_oitr
Apps.Fib.Npc.obelisk.itr (obelisk_id: U120) (chest_id: Apps.Fib.Id) : Apps.Fib.Interaction Unit {
  do Apps.Fib.Interaction {
    //Checks if the puzzle is solved, if true, fails the interaction
    ask state = Apps.Fib.Interaction.entity.get_from_id chest_id
    let solved = Apps.Fib.Npc.obelisk.solved state
    Apps.Fib.Interaction.check solved
    //Makes a pair of data (that is which obelisk is being interacted with) and its right
    let obls = Apps.Fib.Npc.obelisk.pair obelisk_id
    let lft  = Pair.fst obls
    let rgt  = Pair.snd obls
    ask target  = Apps.Fib.Interaction.target.get
    //Apply the successor of the current state to both obelisks and sets the new value
    let fst = (state: U120) => Apps.Fib.U120.mut state lft (U120.new 0 2) (x => Apps.Fib.U120.obelisk_succ x)
    let snd = (state: U120) => Apps.Fib.U120.mut state rgt (U120.new 0 2) (x => Apps.Fib.U120.obelisk_succ x)
    Apps.Fib.Interaction.entity.mut_at_id (x => snd (fst x)) chest_id
    return Unit.new
    }
  }


// Main {
  // let init = Apps.Fib.Npc.obelisk.init0
  // let a = Apps.Fib.U120.mut (U120.inc init) (U120.new 0 0) (U120.new 0 2) (x => Apps.Fib.U120.obelisk_succ x)
  // a
// }
