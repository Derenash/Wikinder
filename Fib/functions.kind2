#kdl_state = Apps.Fib.Kindelia.State.Build
#kdl_name = Fib
Apps.Fib.Kindelia (action: Apps.Fib.Kindelia.Act) : Kindelia.IO Apps.Fib.Kindelia.Response 
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.action code) = do Kindelia.IO {
  ask state = Kindelia.IO.take
  match Apps.Fib.Kindelia.State state {
    new => do Kindelia.IO {
      ask block = Kindelia.IO.tick
      let phs = state.phase
      match Apps.Fib.Kindelia.State.Phase phs {
        game => do Kindelia.IO {
          let p      = Apps.Fib.Kindelia.State.update state code block
          match Pair p {
            new => do Kindelia.IO {
              ask Apps.Fib.Kindelia.save p.fst
                if (Data.BraunTree.is_empty p.snd) {
                  let result = Apps.Fib.Kindelia.Response.act_fail
                  Apps.Fib.Kindelia.done result }
                else {
                  let result = Apps.Fib.Kindelia.Response.acted p.snd
                  Apps.Fib.Kindelia.done result }
            }
               
          }
        }
        lobby => do Kindelia.IO {
          let result = Apps.Fib.Kindelia.Response.wrong_phase
          ask          Apps.Fib.Kindelia.save state
          Apps.Fib.Kindelia.done result
        }
      }
    }
  }
  }
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.get) = do Kindelia.IO {
  ask state  = Kindelia.IO.take
  let result = Apps.Fib.Kindelia.Response.state state
  ask          Kindelia.IO.save state
  return result
  }
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.join subj kgt) = do Kindelia.IO {
  ask s      = Kindelia.IO.take
  ask tick   = Kindelia.IO.tick
  match Apps.Fib.Kindelia.State s {
    new =>
      let phs = s.phase
      match Apps.Fib.Kindelia.State.Phase phs {
        game  => Apps.Fib.Kindelia.join_game subj s.start phs.players s.state
        lobby => Apps.Fib.Kindelia.join_lobby subj kgt s.start s.state phs.queue
        }
    }
}
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.start) = do Kindelia.IO {
  ask state  = Kindelia.IO.take
  ask tick   = Kindelia.IO.tick
  match Apps.Fib.Kindelia.State state {
    new => do Kindelia.IO {
      let phase = state.phase
      match Apps.Fib.Kindelia.State.Phase phase {
        game  => do Kindelia.IO {
          ask Apps.Fib.Kindelia.save state
          return Apps.Fib.Kindelia.Response.wrong_phase
        }
        lobby =>
          let to_start  = U120.new 0 300
          let duration  = U120.sub_saturated tick state.start
          // TODO consider time of the lobby to see if should be started or not
          // let can_start = U120.greater_equal duration to_start
          let can_start = Bool.true
          if can_start {
            let starts = Apps.Fib.Map.initial_positions
            let acc    = Apps.Fib.Kindelia.To_start.new starts User.Sipher.PatriciaTree.empty (Apps.Fib.Kindelia.State.get_state state) (U120.new 0 0)
            let fold   = List.fold phase.queue
            let data   = fold acc Apps.Fib.Kindelia.To_start.to_fold 
            match Apps.Fib.Kindelia.To_start data {
              new => do Kindelia.IO {
                let phase  = Apps.Fib.Kindelia.State.Phase.game data.users
                let timer  = U120.new 0 0
                let state  = data.state 
                let state  = Apps.Fib.Kindelia.State.new phase timer state
                let result = Apps.Fib.Kindelia.Response.started tick
                ask          Apps.Fib.Kindelia.save state
                Apps.Fib.Kindelia.done result
              }
            }
          }
          else { do Kindelia.IO {
            ask        Apps.Fib.Kindelia.save state
            let result = Apps.Fib.Kindelia.Response.start_fail (U120.sub_saturated to_start duration)
            Apps.Fib.Kindelia.done result
          } 
          }
      }
    }
  }
}
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.reset) = do Kindelia.IO {
  ask state  = Kindelia.IO.take
  ask tick   = Kindelia.IO.tick
  match Apps.Fib.Kindelia.State state {
    new => 
      let phase = state.phase
      match Apps.Fib.Kindelia.State.Phase phase {
        lobby => do Kindelia.IO {
          ask    Apps.Fib.Kindelia.save state
          return Apps.Fib.Kindelia.Response.wrong_phase
        }
        game => do Kindelia.IO {
          let phase  = Apps.Fib.Kindelia.State.Phase.init_lobby
          let state  = Apps.Fib.State.Build
          let s_blk  = U120.new 0 0
          let state  = Apps.Fib.Kindelia.State.new phase s_blk state
          ask    Apps.Fib.Kindelia.save state
          return Apps.Fib.Kindelia.Response.reseted
        }
      }
  }
  }
  
#kdl_name = Fib_kdl_jgam
Apps.Fib.Kindelia.join_game (subj: U120) (start: U120) (players: User.Sipher.PatriciaTree) (state: Apps.Fib.State) : Kindelia.IO Apps.Fib.Kindelia.Response {
  let pos     = List.map Apps.Fib.Map.initial_positions (x => Apps.Fib.Pos.new (Apps.Fib.Pos.Value.get_x x) (Apps.Fib.Pos.Value.get_y x)) 
  let p       = Apps.Fib.Kindelia.State.join pos state players subj
  match Maybe p {
    none =>
      do Kindelia.IO {
        let result = Apps.Fib.Kindelia.Response.join_fail
        let state  = Apps.Fib.Kindelia.State.new (Apps.Fib.Kindelia.State.Phase.game players) start state
        ask          Apps.Fib.Kindelia.save state
        Apps.Fib.Kindelia.done result
      }
    some =>
      match Pair p.value {
        new => do Kindelia.IO {
          let players = User.Sipher.PatriciaTree.set players subj p.value.snd
          let state   = Apps.Fib.Kindelia.State.new (Apps.Fib.Kindelia.State.Phase.game players) start p.value.fst
          let result  = Apps.Fib.Kindelia.Response.joined p.value.snd
          ask           Apps.Fib.Kindelia.save state
          Apps.Fib.Kindelia.done result
        }
      }
  }
}

#kdl_name = Fib_kdl_jlob
Apps.Fib.Kindelia.join_lobby (subj: U120) (kgt: U120) (start: U120) (state: Apps.Fib.State) (queue: List Apps.Fib.Kindelia.State.Phase.User) : Kindelia.IO Apps.Fib.Kindelia.Response {
  let find    = Apps.Fib.Kindelia.State.Phase.queue.find queue subj
  match Maybe find {
    none => do Kindelia.IO {
      let user    = Apps.Fib.Kindelia.State.Phase.User.new subj kgt
      let queue   = Apps.Fib.Kindelia.State.Phase.queue.add  queue user
      let find    = Apps.Fib.Kindelia.State.Phase.queue.find queue subj
      let phase   = Apps.Fib.Kindelia.State.Phase.lobby queue
      let state   = Apps.Fib.Kindelia.State.new phase start state
      let result  = 
        match Maybe find {
          some => Apps.Fib.Kindelia.Response.queued find.value        
          none => 
            let floor  = List.last queue
            let value  = Maybe.extract floor (U120.new 0 0) (x => Apps.Fib.Kindelia.State.Phase.User.kgt x)
            Apps.Fib.Kindelia.Response.queue_fail value
        }
      ask result  = Kindelia.IO.norm result
      ask           Apps.Fib.Kindelia.save state
      Apps.Fib.Kindelia.done result
    }
    some =>  do Kindelia.IO {
      let phase   = Apps.Fib.Kindelia.State.Phase.lobby queue
      let state   = Apps.Fib.Kindelia.State.new phase start state
      let result  = Apps.Fib.Kindelia.Response.queue_fail (U120.new 0 0)
      ask           Apps.Fib.Kindelia.save state
      Apps.Fib.Kindelia.done result
    }
  }
}

#kdl_name = Fib_save
Apps.Fib.Kindelia.save (state: Apps.Fib.Kindelia.State) : Kindelia.IO Unit {
  do Kindelia.IO {
    ask state = Kindelia.IO.norm state
    Kindelia.IO.save state
  }
}

#kdl_name = Fib_done
Apps.Fib.Kindelia.done (result: Apps.Fib.Kindelia.Response): Kindelia.IO Apps.Fib.Kindelia.Response {
  do Kindelia.IO {
    ask result = Kindelia.IO.norm result
    return result
  }
}


#kdl_name = Fib_funs
Funs : U120 {
  let skill = Apps.Fib.Kindelia.skill (U120.new 0 0) (U120.new 0 0) (U120.new 0 0) (U120.new 0 0) (U120.new 0 0) (U120.new 0 0)
  let parse = Apps.Fib.Kindelia.State.parse Apps.Fib.Kindelia.Response.none (U120.new 0 0)
  let walk  = Apps.Fib.Kindelia.walk (U120.new 0 0) (U120.new 0 0)
  let start = Apps.Fib.Kindelia.State.Build
  let itr   = Apps.Fib.Kindelia.interact (U120.new 0 0) (U120.new 0 0)
  let user  = Apps.Fib.Kindelia.State.get_user Apps.Fib.Kindelia.Response.none (U120.new 0 0)
  U120.new 0 0
}
