#kdl_state = Apps.Fib.Kindelia.State.Build
#kdl_name = Fib
Apps.Fib.Kindelia (action: Apps.Fib.Kindelia.Act) : Kindelia.IO Apps.Fib.Kindelia.Response 
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.action code current_blk) = do Kindelia.IO {
  ask state = Kindelia.IO.take
  match Apps.Fib.Kindelia.State state {
    new => do Kindelia.IO {
      // ask current_blk = Kindelia.IO.tick
      let phs         = state.phase
      match Apps.Fib.Kindelia.State.Phase phs {
        game => do Kindelia.IO {
          let p = Apps.Fib.State.Update state.state code (U120.sub_saturated current_blk state.start)
          match Pair p {
            new => do Kindelia.IO {
              let state       = Apps.Fib.Kindelia.State.new phs state.start p.fst
              let player_num  = (U120.sub (Apps.Fib.Action.get_id code) (U120.new 0 1024))
              ask Apps.Fib.Kindelia.save state
                if (Data.BraunTree.is_empty p.snd) {
                  let result  = Apps.Fib.Kindelia.Response.act_fail player_num
                  Apps.Fib.Kindelia.done result }
                else {
                  let result  = Apps.Fib.Kindelia.Response.acted player_num p.snd
                  Apps.Fib.Kindelia.done result }
            }
          }
        }
        lobby => do Kindelia.IO {
          let result = Apps.Fib.Kindelia.Response.wrong_phase
          ask          Apps.Fib.Kindelia.save (Apps.Fib.Kindelia.State.new state.phase state.start state.state)
          Apps.Fib.Kindelia.done result
        }
      }
    }
  }
  }
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.get) = do Kindelia.IO {
  ask state  = Kindelia.IO.take
  let result = Apps.Fib.Kindelia.Response.state state
  ask          Kindelia.IO.save state
  return result
  }
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.join subj kgt) = do Kindelia.IO {
  ask s      = Kindelia.IO.take
  ask tick   = Kindelia.IO.tick
  match Apps.Fib.Kindelia.State s {
    new =>
      let phs = s.phase
      match Apps.Fib.Kindelia.State.Phase phs {
        game  => Apps.Fib.Kindelia.join_game subj s.start phs.players s.state
        lobby => Apps.Fib.Kindelia.join_lobby subj kgt s.start s.state phs.queue
        }
    }
}
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.start) = do Kindelia.IO {
  ask state  = Kindelia.IO.take
  ask tick   = Kindelia.IO.tick
  match Apps.Fib.Kindelia.State state {
    new => do Kindelia.IO {
      let phs = state.phase
      match Apps.Fib.Kindelia.State.Phase phs {
        game  => do Kindelia.IO {
          ask    Apps.Fib.Kindelia.save (Apps.Fib.Kindelia.State.new (Apps.Fib.Kindelia.State.Phase.game phs.players) state.start state.state)
          return Apps.Fib.Kindelia.Response.wrong_phase
        }
        lobby =>
          let to_start  = U120.new 0 300
          let duration  = U120.sub_saturated tick state.start
          // TODO consider time of the lobby to see if should be started or not
          // let can_start = U120.greater_equal duration to_start
          let can_start = Bool.true
          if can_start {
            let starts = Apps.Fib.Map.initial_positions
            let acc    = Apps.Fib.Kindelia.To_start.new starts User.Sipher.PatriciaTree.empty state.state (U120.new 0 0)
            let fold   = List.fold phs.queue
            let data   = fold acc Apps.Fib.Kindelia.To_start.to_fold 
            match Apps.Fib.Kindelia.To_start data {
              new => do Kindelia.IO {
                let phs    = Apps.Fib.Kindelia.State.Phase.game data.users
                let state  = Apps.Fib.Kindelia.State.new phs tick data.state
                let result = Apps.Fib.Kindelia.Response.started tick
                ask          Apps.Fib.Kindelia.save state
                Apps.Fib.Kindelia.done result
              }
            }
          }
          else { do Kindelia.IO {
            ask          Apps.Fib.Kindelia.save (Apps.Fib.Kindelia.State.new (Apps.Fib.Kindelia.State.Phase.lobby phs.queue) state.start state.state)
            let result = Apps.Fib.Kindelia.Response.start_fail (U120.sub_saturated to_start duration)
            Apps.Fib.Kindelia.done result
          } 
          }
      }
    }
  }
}
Apps.Fib.Kindelia (Apps.Fib.Kindelia.Act.reset) = do Kindelia.IO {
  ask state  = Kindelia.IO.take
  ask tick   = Kindelia.IO.tick
  match Apps.Fib.Kindelia.State state {
    new => 
      let phase = state.phase
      match Apps.Fib.Kindelia.State.Phase phase {
        lobby => do Kindelia.IO {
          ask    Apps.Fib.Kindelia.save state
          return Apps.Fib.Kindelia.Response.wrong_phase
        }
        game => do Kindelia.IO {
          let phase  = Apps.Fib.Kindelia.State.Phase.init_lobby
          let state  = Apps.Fib.State.Build
          let s_blk  = U120.new 0 0
          let state  = Apps.Fib.Kindelia.State.new phase s_blk state
          ask    Apps.Fib.Kindelia.save state
          return Apps.Fib.Kindelia.Response.reseted
        }
      }
  }
  }
  
#kdl_name = Fib_kdl_jgam
Apps.Fib.Kindelia.join_game (subj: U120) (start: U120) (players: User.Sipher.PatriciaTree) (state: Apps.Fib.State) : Kindelia.IO Apps.Fib.Kindelia.Response {
  let pos     = Apps.Fib.Map.initial_positions
  let p       = Apps.Fib.Kindelia.State.join pos state players subj
  match Pair p {
    new =>
      match Maybe p.snd {
        none =>
          do Kindelia.IO {
            let result = Apps.Fib.Kindelia.Response.join_fail subj
            let state  = Apps.Fib.Kindelia.State.new (Apps.Fib.Kindelia.State.Phase.game players) start p.fst
            ask          Apps.Fib.Kindelia.save state
            Apps.Fib.Kindelia.done result
          }
        some =>
          do Kindelia.IO {
            let players = User.Sipher.PatriciaTree.set players subj p.snd.value
            let state   = Apps.Fib.Kindelia.State.new (Apps.Fib.Kindelia.State.Phase.game players) start p.fst
            let result  = Apps.Fib.Kindelia.Response.joined subj p.snd.value
            ask           Apps.Fib.Kindelia.save state
            Apps.Fib.Kindelia.done result
          }
      }
  }
}

#kdl_name = Fib_kdl_jlob
Apps.Fib.Kindelia.join_lobby (subj: U120) (kgt: U120) (start: U120) (state: Apps.Fib.State) (queue: List Apps.Fib.Kindelia.State.Phase.User) : Kindelia.IO Apps.Fib.Kindelia.Response {
  let find    = Apps.Fib.Kindelia.State.Phase.queue.find queue subj
  match Maybe find {
    none => do Kindelia.IO {
      let user    = Apps.Fib.Kindelia.State.Phase.User.new subj kgt
      let queue   = Apps.Fib.Kindelia.State.Phase.queue.add  queue user
      let find    = Apps.Fib.Kindelia.State.Phase.queue.find queue subj
      let phase   = Apps.Fib.Kindelia.State.Phase.lobby queue
      let state   = Apps.Fib.Kindelia.State.new phase start state
      match Maybe find {
        some => do Kindelia.IO {
          let result = Apps.Fib.Kindelia.Response.queued subj     
          ask          Apps.Fib.Kindelia.save state
          Apps.Fib.Kindelia.done result
        }
        none => do Kindelia.IO {
          let floor  = List.last queue
          let value  = Maybe.extract floor (U120.new 0 0) (x => Apps.Fib.Kindelia.State.Phase.User.kgt x)
          let result = Apps.Fib.Kindelia.Response.queue_fail subj
          ask          Apps.Fib.Kindelia.save state
          Apps.Fib.Kindelia.done result
        }
      }
    }
    some =>  do Kindelia.IO {
      let phase   = Apps.Fib.Kindelia.State.Phase.lobby queue
      let state   = Apps.Fib.Kindelia.State.new phase start state
      let result  = Apps.Fib.Kindelia.Response.queue_fail subj
      ask           Apps.Fib.Kindelia.save state
      Apps.Fib.Kindelia.done result
    }
  }
}

#kdl_name = Fib_save
Apps.Fib.Kindelia.save (state: Apps.Fib.Kindelia.State) : Kindelia.IO Unit {
  do Kindelia.IO {
    ask state = Kindelia.IO.norm state
    Kindelia.IO.save state
  }
}

#kdl_name = Fib_done
Apps.Fib.Kindelia.done (result: Apps.Fib.Kindelia.Response): Kindelia.IO Apps.Fib.Kindelia.Response {
  do Kindelia.IO {
    ask result = Kindelia.IO.norm result
    return result
  }
}


#kdl_name = Fib_funs
Funs : U120 {
  let skill = Apps.Fib.Kindelia.skill (U120.new 0 0) (U120.new 0 0) (U120.new 0 0) (U120.new 0 0) (U120.new 0 0) (U120.new 0 0)
  let parse = Apps.Fib.Kindelia.State.parse Apps.Fib.Kindelia.Response.none (U120.new 0 0)
  let walk  = Apps.Fib.Kindelia.walk (U120.new 0 0) (U120.new 0 0)
  let resp  = Apps.Fib.Kindelia.respawn (U120.new 0 0)
  let start = Apps.Fib.Kindelia.State.Build
  let itr   = Apps.Fib.Kindelia.interact (U120.new 0 0) (U120.new 0 0)
  let user  = Apps.Fib.Kindelia.State.get_user Apps.Fib.Kindelia.Response.none (U120.new 0 0)
  U120.new 0 0
}
